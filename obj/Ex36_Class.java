package com.test.java.obj;

public class Ex36_Class {

	public static void main(String[] args) {
		
		// Ex36_Class
		
		/*
			# 언어의 성향
			1. 절차 지향 프로그래밍
			2. 함수 지향 프로그래밍
			3. 객체 지향 프로그래밍
			
			
			# 자바
			- 객체 지향 프로그래밍 언어, Object Oriented Programming (OOP)
			- 객체를 선호하는 프로그래밍 방식의 언어
			
			
			# 클래스, Class
			
			1. 객체, Object
				- 사전적인 정의로 실제 존재하는 것을 말한다.
				- 객체지향 이론에서는 사물과 같은 유형적인 것뿐만 아니라, 개념이나 논리와 같은 무형적인 것(성격, 기분)들도 객체로 간주한다.
				- 프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.
				
				- 맥도날드는 2000년대에는 주문을 사람이 받았다. 그러나 지금은 모든 주문을 키오스크가 받고 있다.
				- 이처럼 사람이 하던 일을 컴퓨터로 옮겨 놓는 과정에서 어떤 요소를 인식하고 구분짓기 위한 개념이 필요했고, 이를 객체로 표현하기로 한 것이다.
				- 따라서 객체는 전산 용어보다는 철학 용어에 가깝다.
			
			2. 클래스, Class
				- 객체를 분류하는 단위
				- 객체를 생성하는 단위
				- 추상적인 단위로, 눈에 보이지 않는다.
				
				ex) 붕어빵, 붕어빵틀
					a. 붕어빵틀을 만든다. > 클래스
					b. a를 사용해서 붕어빵을 만든다. > 객체
					c. 붕어빵을 먹는다.
					
				ex) 핸드폰
					a. 설계도를 만든다. > 핸드폰틀을 만든다. > 클래스
					b. a를 사용해서 핸드폰을 만든다. > 객체
					c. 핸드폰을 사용한다.
					
					- 객체와 클래스 간의 사이를 잘 나타내는 예시이다.
					- 실제로는 객체(Object)를 사용하는 것이 목적이다. 그 객체를 설계하는 과정을 클래스라고 한다.
					- 설계하고 정의를 하면서 클래스(틀)가 만들어진다. 이것을 가지고 실제적으로 눈에 보이는 객체(Object)를 만들 수 있다.
			
			3. 인스턴스, Instance
				- 객체
				- '객체 == 인스턴스'로 보는 관점
				- '객체 != 인스턴스'로 보는 관점
				
				- 인스턴스에 대한 정의는 메모리에 실체화된 객체이다.
				- 객체는 더 넓은 범위의 정의이고, 메모리에 실체화된 산출물을 인스턴스라고 부른다.
				- 객체와 인스턴스는 비슷한 개념으로 이해하면 된다.
				
			4. 캡슐화, 정보 은닉
				- 오브젝트는 뭔가를 감싸고 있는 형태로 생겼다. (케이스)
				- 객체를 보호하는 역할, 보지 않아도 되거나 보지 못하게 하려고 할 때 사용한다.
				- 캡슐화를 하게 되면 안에 있는 정보가 보이지 않게 되고, 이를 정보 은닉이라고 부른다.
				- 외부로부터 보호하기 위한 장치
				
			5. 인터페이스
				- 정보 은닉을 하게 되면 외부로부터 안전하게 보호할 수는 있지만, 외부과 의사소통을 할 수 있는 최소한의 통로(장치)가 필요하다.
				- 캡슐화된 내부와 외부간의 최소한의 연결이 가능한 통로 역할
				- 단절된 오브젝트는 사용이 불가능하며 쓸모가 없다.
				
				ex) 게임 인터페이스
			
			
			객체 = '데이터' + '행동'의 집합으로 정의
				- 실제 현실에서는 제3, 제4의 무언가가 있다고 볼 수 있지만 보통 '데이터'와 '행동'의 집합으로서 정의한다.
			
			리모콘 = 데이터(회색, 100g, 8cm x 17cm) + 행동(전원 On, 전원 Off, 조작)의 집합
			
			Isaac = 데이터(나이, 몸무게, 피부색, 머리색) + 행동(말한다, 먹는다, 잔다, 달린다, 생각한다)
			
			6. 프로퍼티, Property
				- 객체가 가지는 정보(데이터)
				
			7. 행동
				- 객체가 가지는 행동
			
			8. 상속
				- 부모가 가지는 재산을 자식에게 물려주는 행동
			
			- 추천도서: 객체지향의 사실과 오해 (역할, 책임, 협력 관점에서 본 객체지향) - 조영호
		*/
		
		// 요구사항) 지도를 만드는 중이다 > 우리 집을 표시하고 싶다 > 좌표(위도, 경도)가 있다 > 좌표를 저장하고 싶다
		
		// Case 1.
		// - 가장 간단한 방법
		// - 식별자 문제
		//	a. 같은 성질의 식별자가 서로 다른 이름을 쓰고 있다.
		//	b. 한 쌍의 집합을 물리적으로 관리하는 게 불가능하다.
		// - 구조(X), 규칙(애매) > 조작 불편
		
		// 우리집 좌표 (2차원)
		int x = 100;
		int y = 200;
		
		System.out.println("Case 1. 넘버링");
		System.out.printf("우리집은 [%d,%d]에 위치합니다.\n", x, y);
		
		// 마트 좌표
		// 또 다른 x좌표와 y좌표가 필요하다 > "변수의 이름을 어떻게 해야 하는가?"
		
		int x2 = 300;
		int y2 = 400;
		// 넘버링을 하면 의미 전달은 되지만 식별자가 문제가 된다.
		// 경험상 이름이 중복되는 것을 방지하기 위해 사용했다는 것이 이해가 되지만, 엄밀히 따지면 다른 이름에 데이터가 저장된 것이다.
		// 때문에 x3000, y3000 처럼 넘버링 하는 것은 좋지 않다.
		// 심지어 x의 짝꿍이 y라는 것도 경험상 이해되는 것이지, x의 짝꿍이 y2라는 것일지도 모르는 일이다. 이는 개발자만이 알고 있는 것이다.
		// 나중에 실수가 생길 확률이 굉장히 커지고, 논리적인 오류가 발생하며 오류의 원인을 찾기가 힘들어진다.
		
		System.out.printf("마트는 [%d,%d]에 위치합니다.\n", x2, y2);
		
		
		// Case 2.
		// - 배열 사용
		// - 데이터를 집합으로 관리하면서 구조가 생겼다는 장점이 있다.
		// - x와 y를 물리적으로 한 쌍으로 만들었다.
		// - 배열 단점: 요소간의 성질을 구분하기 힘들다. > 첨자 사용 > 첨자는 의미를 가지지 못한다 > 몇 번째 방에 어떤 데이터를 넣었는지 관리가 힘들다.
		
		// 우리집
		int[] a1 = {100, 200};
		
		// a1[0] > 0 > x좌표
		// a1[1] > 1 > y좌표
		// 배열의 처음에 x를 넣었는지 y를 넣었는지 헷갈린다.
		
		System.out.println("Case 2. 배열");
		System.out.printf("우리집은 [%d,%d]에 위치합니다.\n", a1[0], a1[1]);
		
		int[] a2 = {300, 400};
		System.out.printf("마트는 [%d,%d]에 위치합니다.\n", a2[0], a2[1]);
		
		
		// Case 3.
		// - 클래스 사용 > 데이터의 집합******* 배열만 데이터의 집합이 아니라 클래스도 데이터의 집합이다.
		// - 데이터 저장 구조가 생성되며 관리가 수월해진다.
		// - 같은 클래스의 객체이면 > 멤버 이름이 동일하여 > 데이터의 의미가 명확하다.
		// - 멤버 변수의 이름이 존재한다. > x, y > 배열과 달리 멤버의 의미가 명확하다.
		// - 단점: 클래스 선언 비용이 발생한다. (고가)

		// 클래스명 변수명 = new 생성자();
		Point p1 = new Point(); // new Point()의 의미 = 객체를 생성하라
		// p1: 객체 참조 변수
		
		p1.x = 100; // p1.x: 객체 멤버 변수
		p1.y = 200; // p1.y: 객체 멤버 변수
		
		System.out.println("Case 3. 클래스");
		System.out.printf("우리집은 [%d,%d]에 위치합니다.\n", p1.x, p1.y);
		
		// 마트
		Point p2 = new Point();
		
		p2.x = 300;
		p2.y = 400;
		
		System.out.printf("마트는 [%d,%d]에 위치합니다.\n", p2.x, p2.y);
		
		
		// 요구사항) 크기 저장 > 너비, 높이, 이름
		Size s1 = new Size();
		
		s1.name = "모니터";
		s1.width = 100;
		s1.height = 150;
		
		System.out.println(s1.name);
		System.out.println(s1.width);
		System.out.println(s1.height);
		
		
		// 학생 성적 > 이름, 국어, 영어, 수학 > 집합 (= 학생 1명)
		Score isaac = new Score();
		
		isaac.name = "아이작";
		isaac.kor = 100;
		isaac.eng = 90;
		isaac.math = 80;
		
		System.out.println(isaac.name);
		System.out.println(isaac.kor);
		System.out.println(isaac.eng);
		System.out.println(isaac.math);
		
		// 이클립스 > 확장 프로그램(Plugin - in)
		// 1. 직접 설치
		// 2. 마켓 플레이스
		
		// Objectaid > UML 확장 프로그램
		// - Class Diagram
		
		// UML, Unified Modeling Language
		// - 프로그램의 설계도를 만드는 언어
		// - 수많은 종류의 설계도
		// a. Class Diagram <- 이번 시간에 할 얘기
		// b. Package Diagram
		// c. Object Diagram
		// d. Component Diagram
		// e. Sequence Diagram
		// f. UseCase Diagram
		// g. Activity Diagram
		// h. State Diagram
		// ....
		
		// <<Java Class>>스테레오 타입(카테고리) - 추상, 열거형 등의 종류
		// com.test.java.obj (패키지 위치)
		// Point (클래스 이름)
		// x: int (멤버 변수)
		// Point() (메소드)
		
		
	}// main

}// class

class Score {
	
	public String name;
	public int kor;
	public int eng;
	public int math;
	
}

class Size {
	
	public String name;
	public int width;
	public int height;
	
}

// 클래스를 선언한다 > 붕어빵 틀 만들기
// - 클래스명 > 파스칼 표기법

class Point {
	
	// 클래스 내부
	// 클래스 멤버 선언 > 변수 or 메소드 생성
	
	// 변수 > 클래스 멤버 변수 (지역 변수와 반대)
	public int x;
	public int y;
	
	// public: 
}